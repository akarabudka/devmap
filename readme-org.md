# Организация разработки
### Система
* [на каких ОС работал](#на-каких-ОС-работал-)
* [базовые знания `UNIX`](#базовые-знания-UNIX-)
* Основы работы с файлами
* [Как найти файл с определенной подстрокой в директории со вложенностями?](#Как-найти-файл-с-определенной-подстрокой-в-директории-со-вложенностями?-)
### Система контроля версий
* [Знакомы ли c `Source code management (SCM)` системами - `Git`, `Mercurial`, `SVN`, etc?](#Знакомы-ли-c-SCM-системами---Git,-Mercurial,-SVN,-etc?-)
* [зачем нужны `Source code management (SCM)`](#зачем-нужна-)
* [какими пользовались](#какими-пользовались-)
### Git
* [`gitflow`, `cherypick`, `revert`](#gitflow,-cherypick-)
* [как перенести изменения из одной ветку в другую (2 способа)](#как-перенести-изменения-из-одной-ветку-в-другую-(2-способа)-)
* [зачем нужна команда `git rebase`](#зачем-нужна-команда-git-rebase-)
* [`rebase`, `merge`, `stash`](#Чем-отличается-rebase-от-merge-)
* [разница между `git` и `svn` (если есть)](#разница-между-git-и-svn-(если-есть)-)
### Система тикетов и организация задач
* [зачем нужна](#зачем-нужна-)
* [какими пользовались](#какими-пользовались-)
* [как была организована работа в команде](#как-была-организована-работа-в-команде-)
* [методы разрешения конфликтов](#методы-разрешения-конфликтов-)
* [понимание методологии `Scrum` и ее атрибутов (стендапы, грумминг/оценка бэклога, ретроспективы)](#понимание-методологии-Scrum-и-ее-атрибутов-(стендапы,-грумминг/оценка-бэклога,-ретроспективы)-)

# Организация разработки

### на каких ОС работал [&uarr;](#devmap)

Ubuntu, mac os, и WSL немного

### базовые знания `UNIX` [&uarr;](#devmap)

#### bash

    Оболочка, или шелл (shell) — это программа, в нашем случае названная «bash», что является сокращением от Bourne Again Shell. 
    Оболочка принимает ваши команды и передаёт их операционной системе. 
    Для взаимодействия с системой используются терминалы, такие как gnome-terminal, eterm, nxterm и т. п.

    Bash - это интерпретатор команд. По сути, это обычная программа, которая запускается при старте сеанса оболочки. 
    Мы могли бы запускать не Bash, а скажем, интерпретатор python или ruby, и тогда нам пришлось бы выполнять методы этих языков вместо команд Bash для администрирования системы.

    Bash принимает команды от пользователя и передает их системному загрузчику, а также обеспечивает взаимодействие между командами, 
    обмен информацией и потоками ввода-вывода. Также оболочка предоставляет пользователю удобный интерфейс для работы с историей команд, поиска и замены, а также исправления ранее выполненных команд, а также автодополнение путей.

#### grep

    Утилита grep решает множество задач, в основном она используется для поиска строк, соответствующих строке в тексте или содержимому файлов. 
    Также она может находить по шаблону или регулярным выражениям. Команда в считанные секунды найдёт файл  с нужной строчкой, текст в файле или отфильтрует из вывода только пару нужных строк. А теперь давайте рассмотрим, как ей пользоваться.
     
    Синтаксис команды выглядит следующим образом:
    
    $ grep [опции] шаблон [имя файла...]
    
    Или:
    
    $ команда | grep [опции] шаблон

    Опции - это дополнительные параметры, с помощью которых указываются различные настройки поиска и вывода, например количество строк или режим инверсии.
    Шаблон - это любая строка или регулярное выражение, по которому будет вестись поиск
    Файл и команда - это то место, где будет вестись поиск. Как вы увидите дальше, grep позволяет искать в нескольких файлах и даже в каталоге, используя рекурсивный режим.


#### alias

    Используйте alias, чтобы поименовать часто используемые команды. Например, alias ll='ls -latr' создаст новое сокращение ll

#### xargs

    Не забывайте использовать xargs (или parallel). Это очень мощная штука. 
    Обратите внимание, что вы можете контролировать количество команд на каждую строку (-L), а также параллельность (-P). Если вы не уверены, что делаете что-то правильно, начните с xargs echo. Еще -I{} – полезная штука. Примеры:

    Возможность объединения нескольких команд Linux в терминале и использования их в качестве конвейера, когда каждая следующая команда получает вывод предыдущей - очень мощный и гибкий инструмент. Но команды можно объединять не только так. 
    С помощью утилиты xargs вывод предыдущей команды можно передать в аргументы следующей.

    Синтаксис команды немного запутанный, но в нём можно разобраться:
    
    $ первая_команда | xargs опции вторая_команда аргументы
    
    Сначала выполняется любая первая команда и весь её вывод по туннелю передается в xargs. Затем этот вывод разбивается на строки и для каждой строки вызывается вторая команда, а полученная строка передаётся ей в аргументах.

      find . -name '*.py' | xargs grep some_function
      cat hosts | xargs -I{} ssh root@{} hostname

#### cd
    Перейти в домашнюю директорию можно с помощью cd. Для указания пути к файлам из домашней директории можно воспользоваться префиксом ~ (например, ~/.bashrc). В sh скриптах для обращения к домашней директории можно использовать переменную $HOME.
    Для того, чтобы перейти к предыдущей рабочей директории, используйте cd -

#### netstat

    Узнайте, какие процессы слушают порты через netstat -lntp или ss -plat (для TCP; добавьте -u для UDP).

#### history

    `Для просмотра последних команд используйте history. Повторить команду: !n (где n - порядковый номер истории). `

#### ssh

    Синтаксис команды выглядит следующим образом:

    $ ssh [опции] имя пользователя@сервер [команда]
    Чтобы просто подключиться к серверу по SSH:
    
    ssh user@host

    Мы привыкли подключаться к удаленному серверу, а уже потом выполнять нужные команды, 
    но на самом деле утилита ssh позволяет сразу выполнить нужную команду без открытия терминала удаленной машины. Например:
    
    ssh user@host ls

### Как найти файл с определенной подстрокой в директории со вложенностями? [&uarr;](#devmap)

    использовать find либо же grep

### Знакомы ли c `Source code management (SCM)` системами - `Git`, `Mercurial`, `SVN`, etc? [&uarr;](#devmap)

Наиболее популярны - Git, с большим отрывом идет SVN (Subversion) и Mercurial.
Долю на рынке, сопоставимую с массой электрона, занимают осталные системы : CVS (Concurrent Versions System), Team Foundation Server, Bazaar, Darcs итд.

Git и Mercurial — распределенные системы, SVN — централизованная.

В первом случае у каждого разработчика на локальной машине хранится полная копия репозитория, и он работает с ней автономно, периодически заливая обновления на сервер с главным репозиторием.

При этом Git, в отличие от Mercurial, работает не только с локальными коммитами, но и с локальными ветками, которые можно вовсе не заливать в удаленный репозиторий.

SVN предполагает, что полная версия кода со всеми ветками хранится в удаленном репозитории, а у разработчика локально находится только тот файл, который он сейчас модифицирует.

C этой точки зрения, SVN лучше вписывается в модель коммерческой разработки, где мы ежедневно контролируем объем и качество выполненной работы.

При использовании Git или Mercurial проектному менеджеру необходимо установить правило ежедневных коммитов для разработчиков, это особенно критично для удаленных команд или аутсорсеров.

### зачем нужны Source code management (SCM) [&uarr;](#devmap)

    Доступ к коду. Исходники кода хранятся в удаленном репозитории (хранилище данных), куда обращаются разработчики, чтобы забрать актуальную версию файлов или внести изменения. Так выстраивается командная разработка.
    
    Логирование изменений в коде. Отслеживание коммитов (внесений изменений в код), помогает найти кто, что и когда менял, решить конфликты при модифицировании одних и тех же файлов, откатиться на любое предыдущее состояние.
    
    Ветвление разработки. Программисты параллельно ведут разработку нового функционала в отдельных ветках, не затрагивая работоспособности старого.
    
    Поддержка версионности продуктов. При выпуске обновлений программных продуктов, мы обозначаем релизные версии, например, с помощью тегов, чтобы зафиксировать их в этом состоянии, для дебага или ретроспективы.

### какими пользовались [&uarr;](#devmap)

Git (Github, Gitlab, Bitbucket немного)

В целом, Bitbucket больше подходит для работы распределенных команд, а GitHub хорош для индивидуальных проектов.

Преимуществами Bitbucket в том, что в нем встроена интеграция с другими продуктами Atlassian.
Если команда большая удобнее работать с Jira, если небольшая и задач немного, то подойдет и Trello.

### `gitflow`, `cherypick`, `revert` [&uarr;](#devmap)

Git-flow

    Git-flow — альтернативная модель ветвления Git, в которой используются функциональные ветки и несколько основных веток. Эта модель была впервые опубликована и популяризована Винсентом Дриссеном на сайте nvie. По сравнению с моделью магистральной разработки, в Git-flow используется больше веток, каждая из которых существует дольше, а коммиты обычно крупнее. В соответствии с этой моделью разработчики создают функциональную ветку и откладывают ее слияние с главной магистральной веткой до завершения работы над функцией. Такие долгосрочные функциональные ветки требуют тесного взаимодействия разработчиков при слиянии и создают повышенный риск отклонения от магистральной ветки. В них также могут присутствовать конфликтующие обновления.

    Git-flow можно использовать для проектов, в которых запланирован цикл релизов и реализуется характерная для DevOps методика непрерывной поставки. 
    В этом рабочем процессе используются понятия и команды, которые были предложены в рамках рабочего процесса с функциональными ветками. 
    Однако Git-flow привносит новые специфические роли для разных веток и определяет характер и частоту взаимодействия между ними. 
    Помимо функциональных веток в рамках этого рабочего процесса используются отдельные ветки для подготовки, поддержки и регистрации релизов. 
    При этом вы по-прежнему можете пользоваться преимуществами рабочего процесса с функциональными ветками, такими как запросы pull, изолированные эксперименты и эффективное командное взаимодействие.

git cherry-pick

    Команда git cherry-pick берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. 
    Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.

git revert

    Команда git revert — полная противоположность git cherry-pick. 
    Она создаёт новый коммит, который вносит изменения, противоположные указанному коммиту, по существу отменяя его.


### как перенести изменения из одной ветку в другую (2 способа) [&uarr;](#devmap)

merge или rebase

### зачем нужна команда `git rebase` [&uarr;](#devmap)

git rebase — это «автоматизированный» cherry-pick. Он выполняет ту же работу, но для цепочки коммитов, тем самым как бы перенося ветку на новое место.

это наложение коммитов поверх другого базового коммита. Под базовым понимается тот коммит, к которому применяются коммиты выбранной ветки.

Перебазирование в git используется для придания линейности истории ветки, чтобы удобно отслеживать изменения, или для обновления ветки разработки последними изменениями из основной ветки.

### Чем отличается `rebase` от `merge` - описание `rebase`, `merge`, `stash` [&uarr;](#devmap)

Git Merge

Слияние — обычная практика для разработчиков, использующих системы контроля версий.
Независимо от того, созданы ли ветки для тестирования, исправления ошибок или по другим причинам, слияние фиксирует изменения в другом месте.
Слияние принимает содержимое ветки источника и объединяет их с целевой веткой.
В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.

    Плюсы:

    простота;
    сохраняет полную историю и хронологический порядок;
    поддерживает контекст ветки.


    Минусы:

    история коммитов может быть заполнена (загрязнена) множеством коммитов;
    отладка с использованием git bisect может стать сложнее.

Git Rebase

Rebase — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку.

В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.

    Плюсы:

    Упрощает потенциально сложную историю
    Упрощение манипуляций с единственным коммитом
    Избежание слияния коммитов в занятых репозиториях и ветках
    Очищает промежуточные коммиты, делая их одним коммитом, что полезно для DevOps команд


    Минусы:

    Сжатие фич до нескольких коммитов может скрыть контекст
    Перемещение публичных репозиториев может быть опасным при работе в команде
    Появляется больше работы
    Для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно, и это ужасно.

    Если вы сделаете перемещение неправильно, история изменится, а это может привести к серьезным проблемам, поэтому убедитесь в том, что делаете!

Git squash

    Git squash — это прием, который помогает взять серию коммитов и уплотнить ее. Например, предположим: у вас есть серия из N коммитов и вы можете путем сжатия преобразовать ее в один-единственный коммит. 
    Сжатие через git squash в основном применяется, чтобы превратить большое число малозначимых коммитов в небольшое число значимых. Так становится легче отслеживать историю Git.

    Также этот прием используется при объединении ветвей. Чаще всего вам будут советовать всегда сжимать коммиты и выполнять перебазирование с родительской ветвью (например, master или develop). 
    В таком случае история главной ветки будет содержать только значимые коммиты, без ненужной детализации.

    сжатие коммитов меняет историю Git, поэтому не рекомендуется сжимать ветвь, если вы уже отправили ее в удаленный репозиторий. 
    Всегда выполняйте сжатие до того, как отправить пуш с изменениями.

    git rebase -i HEAD~3

### разница между `git` и `svn` (если есть) [&uarr;](#devmap)


    SVN – централизованная система контроля версий, Git – децентрализованная
    При ветвлении SVN копирует все содержимое ветки, Git – создает указатели

    Основное различие между этими двумя системами заключается в том, что Git — это распределенная система контроля версий, а Sagainst — централизованная система контроля версий. 
    Это означает, что вы держите репозиторий либо на своей машине (распределенный), так что вы можете работать локально, а затем синхронизировать изменения с общим сервером. В SVN весь код размещается в одном месте, и все разработчики должны быть подключены к нему, чтобы каждый мог синхронизировать и загружать изменения с сервера

### зачем нужна [&uarr;](#devmap)

Задачи системы управления проектами
Поддержка планирования проектов (планирование сроков, ресурсов, финансов). Поддержка принятия решений по реализации проектов компании. Контроль реализации проектов компании. Контроль использования в проектах финансовых, трудовых и материальных ресурсов компании.


### какими пользовались [&uarr;](#devmap)

Redmine - для рабочих проектов
Trello - для личных проектов

### как была организована работа в команде [&uarr;](#devmap)

работа велась по методике Waterfall (каскадная модель)

    Waterfall — методика управления проектами, которая подразумевает последовательный переход с одного этапа на другой без пропусков и возвращений на предыдущие стадии. 

    Agile — система идей и принципов «гибкого» управления проектами, на основе которых разработаны популярные методы Scrum, Kanban и другие. Ключевой принцип — разработка через короткие итерации (циклы), в конце каждого из которых заказчик (пользователь) получает рабочий код или продукт. 

Agile стал основой для целого ряда гибких методик, среди которых наиболее известны Scrum, Lean и экстремальное программирование.

    Scrum — методология гибкой разработки на основе Agile, в основе которого лежит «спринт» — отрезок от 1 до 4 недель, по окончанию которого должна быть получена рабочая версия продукта.

    Lean — метод, который вырос на основе системы управления производством Toyota Production System. В его основе — философия постоянного совершенствования на всех уровнях организации, где одно из ключевых понятий — ценность (то, за что готов платить заказчик).

    Экстремальное программирование (XP) — одна из Agile-методик, где важная роль отводится периодической игре в планирование с привлечением заказчика. Она позволяет определить недостатки предыдущей итерации, приоритетность задач, желаемую функциональность продукта с учётом пожеланий заказчика.

Как я считаю, agile лучше использовать в разработке а waterfall в поддержке.


### методы разрешения конфликтов [&uarr;](#devmap)

    Существует несколько основные проявления в коллективе:

    разногласия между личностью и личностью (межличностный),
    между личностью и группой,
    противостояние групповое (межгрупповой). 

    Основными эмоциональными причинами проявления, проявлениями совместной деятельности, выраженной конфликтогенностью взаимодействия, ощущениями ощущений, проявлениями чувств противоречиями, эмоциональными манипуляциями и проявлениями, выявлением проявлений, сознательным выявлением проявлений, столкновением интересов и пр.


    Основные навыки успешного управления конфликтами

    Определить источник конфликта – взвешенный взгляд людей на одну и ту же проблему, расхождение в частностях, ценностях и назначениях.
    Установить связь конфликтующих сторон – поиск общности целей и желание пойти на взаимные уступки.
    Наладить конструктивный диалог – выявление агрессии, резких эмоций и эмоций, встречать диалог на взаимном уважении. Стремиться к заключению выгодного договора для сторон.
    Создать позитивные связи – чем быстрее наладить коммуникацию, тем быстрее сосредоточиться на спорных вопросах и достижении целей.
### понимание методологии `Scrum` и ее атрибутов (стендапы, грумминг/оценка бэклога, ретроспективы) [&uarr;](#devmap)

В настоящее время, Scrum является одной из наиболее популярных «методологий» разработки ПО. Согласно определению, Scrum — это каркас разработки, с использованием которого люди могут решать появляющиеся проблемы, при этом продуктивно и производя продукты высочайшей значимости

В классическом Scrum существует 3 базовых роли:
-Product owner
-Scrum master
-Команда разработки (Development team)

Product owner (PO) является связующим звеном между командой разработки и заказчиком. Задача PO — максимальное увеличение ценности разрабатываемого продукта и работы команды.

Одним из основных инструментов PO является Product Backlog. Product Backlog содержит необходимые для выполнения рабочие задачи (такие как Story, Bug, Task и др.), отсортированные в порядке приоритета (срочности).

Scrum master (SM) является «служащим лидером» (англ. servant-leader). Задача Scrum Master — помочь команде максимизировать ее эффективность посредством устранения препятствий, помощи, обучении и мотивации команде, помощи PO

Команда разработки (Development team, DT) состоит из специалистов, производящих непосредственную работу над производимым продуктом.

Рекомендуемый размер команды — 7 (плюс-минус 2) человека. Согласно идеологам Scrum, команды большего размера требуют слишком больших ресурсов на коммуникации, в то время как команды меньшего размера повышают риски (за счет возможного отсутствия требуемых навыков) и уменьшают размер работы, который команда может выполнить в единицу времени.

Процесс Scrum

Основой Scrum является Sprint, в течении которого выполняется работа над продуктом. По окончанию Sprint должна быть получена новая рабочая версия продукта. Sprint всегда ограничен по времени (1-4 недели) и имеет одинаковую продолжительность на протяжении всей жизни продукта.

Перед началом каждого Sprint производится Sprint Planning, на котором производится оценка содержимого Product Backlog и формирование Sprint Backlog, который содержит задачи (Story, Bugs, Tasks), которые должны быть выполнены в текущем спринте. Каждый спринт должен иметь цель, которая является мотивирующим фактором и достигается с помощью выполнения задач из Sprint Backlog.

Каждый день производится Daily Scrum, на котором каждый член команды отвечает на вопросы «что я сделал вчера?», «что я планирую сделать сегодня?», «какие препятствия на своей работе я встретил?». Задача Daily Scrum — определение статуса и прогресса работы над Sprint, раннее обнаружение возникших препятствий, выработка решений по изменению стратегии, необходимых для достижения целей Sprint'а.

По окончанию Sprint'а производятся Sprint Review и Sprint Retrospective, задача которых оценить эффективность (производительность) команды в прошедшем Sprint'е, спрогнозировать ожидаемую эффективность (производительность) в следующем спринте, выявлении имеющихся проблем, оценки вероятности завершения всех необходимых работ по продукту и другое.
