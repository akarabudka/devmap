# Разработка

* [Интересный крон (запуск скрипта раз в 30 секунд)](#Интересный-крон-(запуск-скрипта-раз-в-30-секунд)-)
* [Защита от спама - предложить интересный способ](#Защита-от-спама---предложить-интересный-способ-)
* [Защита от повторной отправки форм](#Защита-от-повторной-отправки-форм-)
* [Сравнение алгоритмов сортировки](#Сравнение-алгоритмов-сортировки-)
* [Веб-сервисы, отличия, когда что использовать (`soap`, архитектура `rest`)](#Веб-сервисы,-отличия,-когда-что-использовать-(soap,-архитектура-rest)-)
* [`raise condition`](#raise-condition-)
* [`CORS`](#CORS-)
* [`SPINX`](#SPINX-)
* [`Elasticsearch`](#Elasticsearch-)
* [гексагональная архитектура](#гексагональная-архитектура-)
* [`KISS, DRY, YAGNI, BDUF, SOLID, APO и бритва Оккама`](#KISS,-DRY,-YAGNI,-BDUF,-SOLID,-APO-и-бритва-Оккама-)
* [`mapping` в `Doctrine`](#mapping-в-Doctrine-)



# Разработка

### Интересный крон (запуск скрипта раз в 30 секунд) [&uarr;](#devmap)

Крон это минимум минута.
Раз в 30 секунд это значит запускать каждую минуту скрипт который что-то делает, потом спит 30 секунд и еще раз делает.
Как вариант, написать скрипт, который будет запускаться раз в минуту и дёргать файл дважды, между двумя дёрганьями спать 30 секунд.

### Защита от спама - предложить интересный способ [&uarr;](#devmap)

Google ReCaptcha
Блэк лист
Hidden поле которое потом сможем проверять на бэке

### Защита от повторной отправки форм [&uarr;](#devmap)

Ограничение частоты отправки сообщений
Ограничение количества сообщний от одного пользователя
ограничение количества отправляемых сообщений за определенный отрезок времени

### Сравнение алгоритмов сортировки [&uarr;](#devmap)

Сортировка массивов — самая базовая алгоритмическая задача, которую нередко спрашивают на собеседованиях. С другой стороны, в реальном коде массивы сортируют, используя уже готовые функции стандартной библиотеки. Тогда для чего задают подобные вопросы? Обычно собеседующий хочет узнать следующее:

1) Насколько вы вообще в курсе о существовании алгоритмов.
2) Способны ли вы программировать.
3) Как работает ваше алгоритмическое мышление.


    Selection sort (сортировка выбором) – суть алгоритма заключается в проходе по массиву от начала до конца в поиске минимального элемента массива и перемещении его в начало. Сложность такого алгоритма O(n2).

    Bubble sort (сортировка пузырьком) – данный алгоритм меняет местами два соседних элемента, если первый элемент массива больше второго. Так происходит до тех пор, пока алгоритм не обменяет местами все неотсортированные элементы. Сложность данного алгоритма сортировки равна O(n^2).

    Insertion sort (сортировка вставками) – алгоритм сортирует массив по мере прохождения по его элементам. На каждой итерации берется элемент и сравнивается с каждым элементом в уже отсортированной части массива, таким образом находя «свое место», после чего элемент вставляется на свою позицию. Так происходит до тех пор, пока алгоритм не пройдет по всему массиву. На выходе получим отсортированный массив. Сложность данного алгоритма равна O(n^2).

    Quick sort (быстрая сортировка) – суть алгоритма заключается в разделении массива на два под-массива, средней линией считается элемент, который находится в самом центре массива. В ходе работы алгоритма элементы, меньшие чем средний будут перемещены в лево, а большие в право. Такое же действие будет происходить рекурсивно и с под-массива, они будут разделяться на еще два под-массива до тех пор, пока не будет чего разделать (останется один элемент). На выходе получим отсортированный массив. Сложность алгоритма зависит от входных данных и в лучшем случае будет равняться O(n×2log2n). В худшем случае O(n^2). Существует также среднее значение, это O(n×log2n).

    Comb sort (сортировка расческой) – идея работы алгоритма крайне похожа на сортировку обменом, но главным отличием является то, что сравниваются не два соседних элемента, а элементы на промежутке, к примеру, в пять элементов. Это обеспечивает от избавления мелких значений в конце, что способствует ускорению сортировки в крупных массивах. Первая итерация совершается с шагом, рассчитанным по формуле (размер массива)/(фактор уменьшения), где фактор уменьшения равен приблизительно 1,247330950103979, или округлено до 1,3. Вторая и последующие итерации будут проходить с шагом (текущий шаг)/(фактор уменьшения) и будут происходить до тех пор, пока шаг не будет равен единице. Практически в любом случае сложность алгоритма равняется O(n×log2n).

Для сортировки неотсортированного массива, наиболее оптимальным из представленных алгоритмов для сортировки массива является быстрая сортировка. Несмотря на более длительное время выполнения алгоритм потребляет меньше памяти, что может быть важным в крупных проектах.

Однако такие алгоритмы как сортировка выбором, обменом и вставками могут лучше подойти для научных целей, например, в обучении, где не нужно обрабатывать огромное количество данных.

При частично отсортированном массиве результаты не сильно отличаются, все алгоритмы сортировки показывают время примерно на 2-3 миллисекунды меньше. Однако при сортировке частично отсортированного массива быстрая сортировка срабатывает намного быстрее и потребляет меньшее количество памяти.

Пример пузырьковой сортировки

    <?php

    function bubbleSort($coll)
    {
        $size = count($coll);
        // do..while цикл. Работает почти идентично while
        // Разница в проверке. Тут она делается не до выполнения тела, а после.
        // Такой цикл полезен там, где надо выполнить тело хотя бы раз в любом случае.
        do {
            // Объявляем переменную swapped, значение которой показывает был ли
            // совершен обмен элементов во время перебора массива
            $swapped = false;
            // Перебираем массив и меняем местами элементы, если предыдущий
            // больше, чем следующий
            for ($i = 0; $i < $size - 1; $i++) {
                if ($coll[$i] > $coll[$i + 1]) {
                    // temp – временная переменная для хранения текущего элемента
                    $temp = $coll[$i];
                    $coll[$i] = $coll[$i + 1];
                    $coll[$i + 1] = $temp;
                    // Если сработал if и была совершена перестановка,
                    // присваиваем swapped значение true
                    $swapped = true;
                }
            }
            // Уменьшаем счетчик на 1, т.к. самый большой элемент уже находится
            // в конце массива
            $size--;
        } while ($swapped); // продолжаем, пока swapped === true

        return $coll;
    }

    print_r(bubbleSort([3, 2, 10, -2, 0]));
    // => Array
    // => (
    // =>     [0] => -2
    // =>     [1] => 0
    // =>     [2] => 2
    // =>     [3] => 3
    // =>     [4] => 10
    // => )


### Веб-сервисы, отличия, когда что использовать (`soap`, архитектура `rest`) [&uarr;](#devmap)

### REST

REST означает REpresentational State Transfer (Википедия: «передача состояния представления»). Это популярный архитектурный подход для создания API в современном мире.

Протокол HTTP

    Когда вы вводите в браузере URL-адрес, например www.google.com, на сервер отправляется запрос на веб-сайт, идентифицированный URL-адресом.
    Затем этот сервер формирует и выдает ответ. Важным является формат этих запросов и ответов. Эти форматы определяются протоколом HTTP — Hyper Text Transfer Protocol.

    Когда вы набираете URL в браузере, он отправляет запрос GET на указанный сервер. Затем сервер отвечает HTTP-ответом, который содержит данные в формате HTML — Hyper Text Markup Language. Затем браузер получает этот HTML-код и отображает его на экране.

    Допустим, вы заполняете форму, присутствующую на веб-странице, со списком элементов. В таком случае, когда вы нажимаете кнопку «Submit» (Отправить), HTTP-запрос POST отправляется на сервер.

HTTP и RESTful веб-сервисы

    HTTP обеспечивает базовый уровень для создания веб-сервисов. Поэтому важно понимать HTTP. Вот несколько ключевых абстракций.

    Ресурс

    Ресурс — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:

        Конкретный пользователь
        Конкретная задача
        Список задач


    URI ресурса

    Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например:

        Создать пользователя: POST /users
        Удалить пользователя: DELETE /users/1
        Получить всех пользователей: GET /users
        Получить одного пользователя: GET /users/1

REST и Ресурсы

    Важно отметить, что с REST вам нужно думать о приложении с точки зрения ресурсов:
    Определите, какие ресурсы вы хотите открыть для внешнего мира
    Используйте глаголы, уже определенные протоколом HTTP, для выполнения операций с этими ресурсами.

    Вот как обычно реализуется служба REST:

    - Формат обмена данными: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML
    
    - Транспорт: всегда HTTP. REST полностью построен на основе HTTP.
    
    - Определение сервиса: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как WADL (Web Application Definition Language) и Swagger.


    REST фокусируется на ресурсах и на том, насколько эффективно вы выполняете операции с ними, используя HTTP.

Компоненты HTTP

    HTTP определяет следующую структуру запроса:

        строка запроса (request line) — определяет тип сообщения
        заголовки запроса (header fields) — характеризуют тело сообщения, параметры передачи и прочие сведения
        тело сообщения (body) — необязательное


    HTTP определяет следующую структуру ответного сообщения (response):

        строка состояния (status line), включающая код состояния и сообщение о причине
        поля заголовка ответа (header fields)
        дополнительное тело сообщения (body)


    Метод, используемый в HTTP-запросе, указывает, какое действие вы хотите выполнить с этим запросом. Важные примеры:

        GET: получить подробную информацию о ресурсе
        POST: создать новый ресурс
        PUT: обновить существующий ресурс
        DELETE: Удалить ресурс


    Код состояния всегда присутствует в ответе HTTP. Типичные примеры:

        200 — успех
        404 — cтраница не найдена


### REST и SOAP

REST и SOAP на самом деле не сопоставимы. SOAP — это формат протокола, основанный на XML, тогда как REST — это архитектурный подход.

Давайте сравним популярные реализации стилей REST и SOAP.

    - Пример реализации RESTful: JSON через HTTP
    - Пример реализации SOAP: XML поверх SOAP через HTTP

Формат обмена сообщениями

    - В SOAP вы используете формат SOAP XML для запросов и ответов.

    - В REST такого фиксированного формата нет. Вы можете обмениваться сообщениями на основе XML, JSON или любого другого удобного формата. JSON является самым популярным среди используемых форматов.

Определения услуг

    - SOAP использует WSDL (Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML.
    
    - REST не имеет стандартного языка определения сервиса. Несмотря на то, что WADL был одним из первых предложенных стандартов, он не очень популярен. Более популярно использование Swagger или Open API.

Транспорт

    SOAP не накладывает никаких ограничений на тип транспортного протокола. Вы можете использовать либо Web протокол HTTP, либо MQ.

    REST подразумевает наилучшее использование транспортного протокола HTTP

Простота реализации

    RESTFful веб-сервисы, как правило, гораздо проще реализовать, чем веб-сервисы на основе SOAP.

    REST обычно использует JSON, который легче анализировать и обрабатывать. В дополнение к этому, REST не требует наличия определения службы для предоставления веб-службы.

    Однако в случае SOAP вам необходимо определить свой сервис с использованием WSDL, и при обработке и анализе сообщений SOAP-XML возникают большие накладные расходы.

Всякий раз, когда вы разрабатываете сервис, такой как REST API или SOAP API, вы можете выбрать один из двух подходов:

    - Code First и генерируйте контракт из кода
    - Contract First и разработка кода на основе контракта

### HATEOAS

Термин HATEOAS означает фразу «Hypermedia As The Engine Of Application State» (Гипермедиа как двигатель состояния приложения).


Когда вы отправляете запрос для получения данных к примеру -  учетной записи, вы получаете оба:

    Номер счета и данные баланса
    Ссылки, которые обеспечивают действия, чтобы сделать депозит/снятие/перевод/закрытие


С HATEOAS запрос на REST ресурс дает мне как данные, так и действия, связанные с данными.

Зачем нам нужен HATEOAS?

Единственная самая важная причина для HATEOAS — слабая связь (loose coupling). Если потребителю службы REST необходимо жестко закодировать все URL-адреса ресурсов, он тесно связан с реализацией вашей службы. Вместо этого, если вы вернете URL-адреса, которые он может использовать для действий, он будет слабосвязанным. Нет строгой зависимости от структуры URI, так как она указана и используется в ответе.

### HAL — язык гипертекстовых приложений

При разработке службы RESTful необходимо указать, как возвращать данные и ссылки, соответствующие запросу. HAL — это формат, который обеспечивает простой и согласованный способ гиперссылки между ресурсами в вашем REST API.


### `raise condition` [&uarr;](#devmap)

Состояние гонки (англ. race condition), также конкуренция[1] — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Термин состояние гонки относится к инженерному жаргону и появился вследствие неаккуратного дословного перевода английского эквивалента. В более строгой академической среде принято использовать термин неопределённость параллелизма.

Состояние гонки — «плавающая» ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и «пропадающая» при попытке её локализовать.

Возможные последствия

    утечки памяти
    ошибки сегментирования
    порча данных
    уязвимости
    взаимные блокировки
    утечки других ресурсов, например файловых дескрипторов

Как с этим бороться:

В первую очередь это конечно же архитектурная проблема, если правильно спроектировать веб-приложение, можно избежать подобных гонок.

Обычно, применяют следующие методы борьбы с атакой:

    Используют блокировки.

    Операция блокирует в СУБД обращения к заблокированному объекту, пока его не разблокируют. Другие стоят и ждут в сторонке. Необходимо правильно работать с блокировками, не блокировать ничего лишнего.


    Рулят изоляциями транзакций.

    Упорядоченные транзакции (serializable) — гарантируют, что транзакции будут выполнены строго последовательно, однако, это может сказаться на производительности.


    Используют мьютексные семафоры (хе-хе).

    Берут какую-нибудь штуку (например etcd). В момент вызова функций создают запись с ключом, если не получилось создать запись, значит она уже есть и тогда запрос прерывается. По окончании обработки запроса запись удаляется.


### `CORS` [&uarr;](#devmap)

Ошибка в консоли вашего браузера

    No ‘Access-Control-Allow-Origin’ header is present on the requested resource.

    Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://example.com/

    Access to fetch at ‘https://example.com’ from origin ‘http://localhost:3000’ has been blocked by CORS policy.

Это примеры CORS-ошибок.CORS — это невероятно полезный механизм в мире неправильно настроенных веб серверов, злоумышленников, орудующих в интернете и организаций, продвигающих веб-стандарты.

Если браузер запрашивает тег из источника, который отличается от получателя по схеме, в полностью определенному имени хоста или порту, то это и есть запрос между различными источниками (cross-origin request).


Источники & cross-origin

Источник идентифицируется следующей тройкой параметров: схема, полностью определенное имя хоста и порт. Например, <http://example.com> и <https://example.com> имеют разные источники: первый использует схему http, а второй https. Вдобавок, портом для http по умолчанию является 80, тогда как для https — 443. Следовательно, в данном примере 2 источника отличаются схемой и портом, тогда как хост один и тот же (example.com).

Таким образом, если хотя бы один из трех элементов у двух ресурсов отличается, то источник ресурсов также считается разным.

CORS — это механизм, который дает контролировать доступ к тегам на веб странице по сети. Механизм классифицируется на три разные категории доступа тегов:

    - Запись из разных источников
    - Вставка из разных источников 
    - Считывание из разных источников 


Вставки из разных источников — это теги, загружаемые через <script>, <link>, <img>, <video>, <audio>, <object>, <embed>, <iframe> и т.п. Все они разрешены по умолчанию. <iframe> выделяется на их фоне, так как он используется для загрузки другой страницы внутри фрейма. Его обрамление в зависимости от источника может регулироваться посредством использования заголовка  X-Frame-options.

Что касается <img> и других вставных тегов, то они устроены так, что сами инициируют запросы из разных источников cross-origin запроса. Именно поэтому в CORS существует различие между вставкой из разных источников и считыванием из разных источников.

Считывание из разных источников  — это теги, загружаемые через вызовы AJAX/ fetch. Все они по умолчанию заблокированы вашим браузером. Существует обходной путь для вставки таких тегов на странице, но такие трюки регулируются другой политикой, которая соблюдается в современных браузерах.


### `SPINX` [&uarr;](#devmap)

Sphinx – система полнотекстового поиска. Из плюсов – наличие лемматизаторов ru, en, du, большое количество стеммеров индексации и поиска: full-text, фасетный, geo. Нет ничего лишнего, лишь поисковый движок с быстрой индексацией и своим индексером. При правильной конфигурации RT индексов можно достичь real time indexing. В отличие от Elasticsearch наблюдаем умеренное использование памяти.

Что касается минусов, то главный из них – необходимость самому просчитывать всю структуру индексов, а значит, масштабирование проходит не так просто. Также у системы скудный API, нет возможности для визуализации, отсутствует fuzzy-поиск по дефолту (но можно реализовать свой) и скудное community.

Sphinx написан на C++. Им пользуются такие мастодонты, как Habr, Викимапия, Craigslist, поддерживается 1С-Битрикс.

Sphinx с 2016 года прекратился свое развитие и теперь альтернатива это форк сфинкса - Manticore

### `Elasticsearch` [&uarr;](#devmap)

Теперь несколько слов про Elasticsearch. Поисковая система проводит всю индексацию внутри себя, при этом управление индексами через RESTful API. Плюсы ElasticSearch – это фасетный поиск, легкое и мощное API, большое количество стеммеров, гибкая структура индексов и создание индексов постфактум. С техниками поиска тут тоже все хорошо: Full-text search, а также алгоритмы Geo и Fuzzy.

В Elasticsearch тоже много готовых реализованных модулей для ES, есть возможность хранить данные, Real Time индексация, достаточно легко масштабируется, ETL-механизмы, и что немаловажно – обширное community. Elasticsearch написан на Java и используется в Wikimedia, Mozilla, SoundCloud, GitHub и других площадках.

Что касается минусов Elasticsearch, то в их числе отсутствие своего индексера (необходимо реализовать свой или logstash в ELK), съедает много памяти, а лемматизаторы русского текста ставятся отдельно плагином.

Если бы нас попросили описать Sphinx и Elasticsearch одним выражением, то первую систему поиска мы бы охарактеризовали словами «быстрая индексация», а вторую – «мощный API».

### гексагональная архитектура [&uarr;](#devmap)

Гексагональная архитектура, это слоеная архитектура, также иногда называемая архитектурой портов и адаптеров. Называют ее так потому, что в рамках этой архитектуры имеется концепция различных портов, которые могут быть использованы (адаптированы) для использования с другими слоями.

Основное назначение этой архитектуры:

    Позволяет взаимодействовать с приложением как пользователю, так и программам, автоматическим тестам, скриптам пакетной обработки. Также позволяет разрабатывать и тестировать приложение без каких-либо дополнительных устройств или баз данных.

Почему Гексагон

    Несмотря на то, что архитектура называется гексагональной, что должно указывать на фигуру с определенным количеством граней, основной мыслью все же является то, что граней у этой фигуры много. Каждая грань представляет собой «порт» доступа к нашему приложению или же его связь с внешним миром.

    Порт может быть представлен как какой-либо проводник входящих запросов (или данных) к нашему приложению. Например, через HTTP-порт (запросы браузера, API) приходят HTTP запросы, которые конвертируются в команды для приложения. Похожим образом могут действовать различные менеджеры очередей или что угодно взаимодействующее с приложением по протоколу пересылки сообщений (например AMQP). Все это является лишь портами через которые мы можем попросить приложение сделать какие-то действия. Эти грани составляют множество «входящих портов». Другие порты могут быть использованы для доступа к данным со стороны приложения, например порт базы данных.


Основа данной архитектуры - порты и адаптеры.

    Порты - это интерфейсы нашего приложения,

    Адаптеры -  реализация наших портов.

    Гексагон - фигура, имеющая 6 сторон, шестиугольник. В нашем случае слоистая или многогранная архитектура.

Преимущества данного метода:

    Независимость: возможность не зацикливаться на бизнес логике.
    Можно задекларировать, описать схему работы нашего приложения до создания внешних сервисов, использовать замоканные данные в реализации адаптеров.

    Гибкость: использование любых фреймворков, перенос доменов адаптеров в другие проекты, добавление новых адаптеров без изменения исходного кода.

    Легкая изменчивость: изменения в одной области нашего приложения не влияют на другие области.

Минусы

    Погружение: многим разработчикам может быть сложно освоиться, особенно, при невысоком уровне знаний. Долгое время я сам отторгал данный подход, ссылаясь на его избыточность, пока не освоил систему на практике в течение нескольких месяцев.

    Также могут возникнуть сложности реализации с graphql.


Слои приложения

    Слой предметной области (Domain Layer)

    В самом центре нашего приложения расположен слой предметной области. Этот слой содержит в себе реализацию бизнес логики и определяет, как внешние слои могут с ней взаимодействовать.
    В добавок к бизнес логике (ядро предметной области или core domain), в слое предметной области часто можно встретить дополнительную логику, например события предметной области (domain events, события, которые выбрасываются в ключевых точках бизнес логики) и “сценарии использования” или use-cases (определение того, что должно делать наше приложение).


    Слой приложения (Application Layer)

    Этот слой занимается исключительно оркестрацией действий, производимых над сущностями из слоя предметной области. Также этот слой является адаптером запросов из слоя фреймворка и отделяет его от слоя предметной области.

    Например этот слой может содержать класс-обработчик, который выполняет какой-то юз-кейс. Этот класс-обработчик принимает входящие данные, пришедшие к нему из слоя фреймворка, и будет выполнять над ними какие-то действия, которые требуются для выполнения нашего юз-кейса.

    Также он может отправлять на обработку события (domain events), которые произошли в слое предметной области.

    Это внешний слой кода, составляющего наше приложение.


    Слой фреймворка (Framework Layer)

    Наше приложение укутано в слой фреймворка (его также называют инфраструктурным слоем, infrastructure layer). Как уже было сказано выше, этот слой содержит код, который использует ваше приложение, но при этом он не является сам по себе частью приложения. Обычно этот слой представлен вашим фреймворком, но конечно же может включать в себя любые сторонние библиотеки, SDK и любой другой код. Вспомните все библиотеки, которые вы подключили через composer (предположим что мы все же пишем на PHP). Они не являются частью вашего фреймворка, но все же они объединены в один слой. Весь этот слой необходим лишь для одного — выполнять различные задачи для удовлетворения потребностей нашего приложения.


Взаимодействие слоев: границы

    Как уже было сказано выше, каждый слой регламентирует то, каким образом другим слоям можно с ним взаимодействовать. Если конкретнее, то каждый слой ответственен за определение того, каким образом с ним будет взаимодействовать каждый следующий внешний слой.

    Инструментом для этого нам послужат интерфейсы. На границе каждого слоя мы найдем интерфейсы. Эти интерфейсы являются портами для следующих слоев, в которых будут реализованы адаптеры.


SOLID как основа гексагональной архитектуры

    Строгое следование всем этим принципам приведёт к тому, что вместо интерфейсов бизнес-логики и репозиториев будет множество отдельных функциональных интерфейсов. Что же до классов, реализующих эти интерфейсы, а так же зависящих от них, то тут возможны варианты.

    Вариант, который приглянулся мне больше всего — придерживаться той же логики, один класс — реализация одного интерфейса. Каждый такой класс будет содержать свой минимум зависимостей и кода, ровно, как и его тестовый класс. Кроме того такая атомизация кода позволяет из одной кодовой базы получить абсолютно разные сервисы:

    Можно собрать модульный монолит, который предоставляет полный набор API проекта.
    
    Можно собрать набор микросервисов, каждый из которых предоставляет API своей предметной области, если их в проекте несколько.

    Можно собрать отдельные микросевисы для API запросов и API команд, применив архитектурный шаблон проектирования CQRS.

    В конечном итоге можно собрать для каждого метода API отдельный микросервис, получив в итоге FaaS.

Таким образом гексагональная архитектура может быть идеальной основой для проектов с микросервисной архитектурой.

Альтернативный вариант — реализовывать несколько взаимосвязанных интерфейсов в одном классе, но помнить, что при необходимости этот класс можно разделить.


### `KISS, DRY, YAGNI, BDUF, SOLID, APO и бритва Оккама` [&uarr;](#devmap)

1. YAGNI
   You Aren’t Gonna Need It / Вам это не понадобится

Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.

Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.

Может наступить день, когда они снова понадобятся – тогда вы сможете воспользоваться git-репозиторием, чтобы воскресить их из мертвых.


2. DRY
   Don’t Repeat Yourself / Не повторяйтесь

Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».

Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?

Использование SSOT позволит создать более прочную и понятную кодовую базу.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.


3. KISS
   Keep It Simple, Stupid / Будь проще

Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее.

У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и рекламная метафора.

Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.

Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.


4. Big Design Up Front
   Глобальное проектирование прежде всего

Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано.

Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив план, вы избавите себя от необходимости раз за разом начинать с нуля.

Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех.

Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть другого шанса справиться с этими ошибками.


5. SOLID

SOLID - это принципы разработки программного обеспечения, следуя которым Вы получите хороший код, который в дальнейшем будет хорошо масштабироваться и поддерживаться в рабочем состоянии.

    S - Single Responsibility Principle - принцип единственной ответственности. Каждый класс должен иметь только одну зону ответственности.

    O - Open closed Principle - принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для изменения.

    L - Liskov substitution Principle - принцип подстановки Барбары Лисков. Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.

    I -  Interface Segregation Principle - принцип разделения интерфейсов. Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.

    D - Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.


6. Avoid Premature Optimization
   Избегайте преждевременной оптимизации

Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана. Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок.

Поймите правильно, предвидеть, что произойдет что-то плохое – это хорошо. Но прежде чем вы погрузитесь в детали реализации, убедитесь, что эти оптимизации действительно полезны.

Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости.

Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок.

Многие считают преждевременную оптимизацию корнем всех зол.


7. Бритва Оккама

Что это значит в мире программирования? Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

### `mapping` в `Doctrine` [&uarr;](#devmap)

Doctrine — объектно-реляционный проектор (ORM) для PHP 7.1+, который базируется на слое абстракции доступа к БД (DBAL). Одной из ключевых возможностей Doctrine является запись запросов к БД на собственном объектно-ориентированном диалекте SQL, называемом DQL (Doctrine Query Language) и базирующемся на идеях HQL (Hibernate Query Language).

Doctrine ORM применяется во фреймворках Laravel, Yii, Symfony.

Doctrine ORM предоставляет разработчику удобные средства выборки данных. Это и мощный DQL для работы в объектно-ориентированном ключе, и удобный Query Builder, простой и понятный в использовании. Они покрывают большую часть потребностей, но иногда возникает необходимость использовать SQL запросы, оптимизированные или специфичные для конкретной СУБД. Для работы с результатами запросов в коде важно понимание того, как работает маппинг в Doctrine.

В основе Doctrine ORM лежит паттерн Data Mapper, изолирующий реляционное представление от объектного, и конвертирующий данные между ними. Одним из ключевых компонентов этого процесса является объект ResultSetMapping, с помощью которого описывается, как именно преобразовывать результаты запроса из реляционной модели в объектную. Doctrine всегда использует ResultSetMapping для представления результатов запроса, но обычно этот объект создается на основе аннотаций или yaml, xml конфигов, остается скрыт от глаз разработчика, потому о его возможностях знают далеко не все.

В Doctrine есть два QueryBuilder — SQL и ORM (DQL). ResultSetMapping предназначен для работы с SQL-запросами, а метод createQueryBuilder EntityManager'a вернет Вам ORM QueryBuilder. В последнем случае я не вижу необходимости использовать ручной ResultSetMapping, т.к. запрос Вы составляете уже в терминах описанных сущностей, используя DQL. В первом же случае, при использовании SQL QueryBuilder, поля в выборке переименовываться не будут.
