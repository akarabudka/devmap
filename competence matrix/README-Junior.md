# Junior


#  Теоретическая подготовка

Структуры данных
1. Не может объяснить разницы между Array (массивом) и LinkedList (связным списком)
2. Способен объяснить принцип работы массивов, списков, словарей и использовать их для решения практических задач	
3. Осознаёт, какие компромиссы между объёмом занимаемой памяти и быстродействием имеют место в базовых структурах данных, какие операции и почему легче выполнять для массивов, а какие — для списков. Может привести и объяснить способы реализации хеш-таблиц и разрешений коллизий в них. Приоритетные очереди и способы их реализации.	
4. Знает и понимает продвинутые структуры данных: B-деревья, биномиальные и фибоначчи-кучи, красно-чёрных деревья, «выворачивающиеся» (Splay) деревья, слоёные списки (skip lists), префиксные и суффиксные деревья и т.п.

Алгоритмы
1. Не способен найти среднее значение чисел в массиве (сложно поверить, но случаются и такие кандидаты)	
2. Знает основные алгоритмы сортировки, поиска, обхода и выборки даннных.	
3. Деревья и Графы. Простые «жадные » алгоритмы и алгоритмы вида «разделяй-и-властвуй» (вроде QuickSort). Способен понять смысл обозначения уровней в этой матрице.	
4. Способен распознать и программно решить задачи динамического программирования, хорошо знает алгоритмы работы с графами, вычислительные алгоритмы. Способен распознать класс сложности задачи и т.п.

Системное программирование
1. Не знает, что такое компилятор, сборщик или интерпретатор.	
2. Базовое понимание компиляторов, сборщиков и интерпретаторов. Понимает, что такое машинный код, и как всё работает на аппаратном уровне. Некоторые знания в сфере виртуальной памяти.	
3. Понимает отличия пользовательского режима от режима ядра, многопоточность, примитивы синхронизации и то, как они реализованы. Способен читать машинный код. Понимает работу сетей, сетевые протоколы и программирование уровня сокетов.	
4. Понимает весь программный стек, детали аппаратной реализации (ЦПУ + Память + Кэш + Прерывания + Микрокоманды), сборки, статическое и динамическое связывание, компиляция, интерпретация, компиляция времени выполнения, сбор мусора, стек, куча, адресация в памяти…




# Инфраструктура разработки

Системы контроля версий
1. Архивные папки по датам	
2. VSS и начинающий пользователь CVS/SVN	
3. Имеет опыт в использовании возможностей CVS или SVN, умеет создавать ветки и сливать, настраивать свойства репозитория и т.п.	
4. Знаком с распределёнными системами контроля версий. Пробовал Bzr/Mercurial/Darcs/Git

Автоматизация сборки
1. Умеет собирать из ИСР (Интегрированная среда разработки — IDE)	
2. Умеет собирать из командной строки	
3. Может настроить скрипт для сборки системы	
4. Может настроить скрипт для сборки системы, а также генерации документации, установочных пакетов, заметок о выпуске и для установки соответствующих меток в системе контроля версий.

Знание средств разработки
1. Ограничено «родной» ИСР (IDE) (VS.Net, Eclipse и т.п.)	
2. Знает о некоторых альтернативных средствах, представляет возможности других ИСР.	
3. Хорошее знание редакторов, отладчиков, ИСР, свободных альтернатив и т.п. Приветствуется знание, например, программ из списка Скотта Хансельмана	
4. Сам автор утилит и скриптов, желательно опубликованных.

Работа со средой разработки (IDE)
1. Использует ИСР для правки текстов.	
2. Детальнее знаком с интерфейсом, способен эффективно пользоваться средой посредством меню.	
3. Знаком с горячими клавишами для часто используемых операций.	
4. Создаёт собственные макросы и расширения.

Написание сценариев
1. Не приходилось писать сценариев	
2. Командные скрипты ОС, JS for scripting	
3. Perl/Python/Ruby/VBScript/Powershell	
4. Создал и опубликовал повторно используемые сценарии.




# Программирование

Декомпозиция задачи
1. «Линейное» кодирование; повторное использование путём копирования-вставки.	
2. Способен разбить задачу на несколько функций	
3. Способен создать повторно используемые функции/объекты, которые решают общую задачу	
4. Используя соответствующие структуры данных и алгоритмы получает обобщённый/объектно-ориентированный код, в котором инкапсулированы и нужным образом выделены те аспекты задачи, которые могут измениться.

Декомпозиция системы
1. Не мыслит шире уровня отдельного класса/файла	
2. Способен декомпозировать задачу и спроектировать решение, но оставаясь в рамках той же технологии/платформы.	
3. Способен проектировать системы, простирающиеся на несколько технологий/платформ.	
4. Способен представлять и проектировать сложные системы из множества продуктов с интеграцией с внешними системами.

Организация кода в рамках файла
1. Никаких признаков организации кода	
2. Методы сгруппированы логически или по уровням видимости	
3. Код оформлен в регионы и достаточно прокомментирован	
4. Файл чётко структурирован, документирован, все пробелы и новые строки расставлены в соответствии со стандартом кодирования. Файл выглядит идеальным.

Организация кода между файлами
1. Не принимает во внимание организацию файлов в папки.	
2. Связанные файлы сгруппированы в папки.	
3. Каждый файл имеет чёткую единственную цель, например, определение одного класса, реализация одной возможности и т.п.	
4. Организация кода на физическом уровне соответствует дизайну. Просмотр имён файлов и папок даёт представление об архитектуре данного фрагмента системы.

Организация проектов в решении
1. Разделение на проекты практически отсутствует (например, и слой UI, и логика, и данные — в одном проекте)	
2. Базовое разделение проектов по уровням.	
3. Бинарные внешние сборки, документация, внешний код, результаты сборки — всё логично организовано в соответствующие папки. Контролирует зависимости между проектами.	
4. Физическое расположение исходников в дереве соответствуюет логической структуре и организации системы. Просмотр имён файлов и папок даёт представление об архитектуре системы.

Читаемость кода
1. Однобуквенные имена	
2. Смысловые имена для файлов, переменных, методов, классов и т.п.	
3. Нет длинных функций; необычный код, исправления ошибок, предположения — прокомментированы	
4. Допущения верифицируются с помощью Assert или контрактов кода. Поток выполнения выглядит естественно, нет слишком глубокой вложенности условий или вызовов.

Навыки общения
1. Не может донести мысли/идеи коллегам. Орфографические и грамматические ошибки.	
2. Может донести мысли/идеи коллегам. Грамотная речь и письмо.	
3. Способен эффективно обсуждать архитектурные и прочие детали с коллегами.	
4. Способен понимать и сообщать мысли/архитектурные идеи/спецификации в непротиворечивой форме и в общении ориентируется на контекст (на понимание собеседниками друг друга). Может обучать других.

Автоматизированное тестирование
1. Считает, что всё тестирование — работа тестировщика	
2. Пишет автоматические тесты, приходит к созданию хороших тестов для уже написанного кода	
3. Пишет код в манере РЧТ (разработка через тестирование, TDD)	
4. Способен настроить автоматизированные функциональные, нагрузочные и тесты интерфейса.

Защитное кодирование
1. Не понимает, что это такое	
2. Проверяет все переданные параметры, декларативно проверяет допущения в коде.	
3. Проверяет возвращаемые значения и проверяет на исключения код, который может их выбросить.	
4. Имеет собственную библиотеку для защитного кодирования; пишет модульные тесты для проверки работы в случае некорректных условий.

Обработка ошибок
1. Кодирует в расчёте на отсутствие ошибок.	
2. Базовая обработка кода, который может выбросить исключение/сгенерировать ошибку.	
3. Убеждается, что ошибки/исключения оставляют программу в корректном состоянии, освобождаются все ресурсы, требующие освобождения: память, подключения и др.	
4. Старается не допустить возникновения исключений путём упреждающих проверок, поддерживает общую стратегию обработки исключений во всех слоях приложения. Предлагает набор общий правил для обработки исключений во всей системе.

Отношение к требованиям
1. Берёт требования и реализует их формально	
2. Ставит вопросы по упущеным ньюансам в требованиях	
3. Понимает общую картину и указывает на целые сферы, которые нужно уточнить/доописать	
4. Способен предложить лучшие альтернативы предлагаемым решениям исходя из личного опыта

Базы данных
1. Считает базой данных Excel	
2. Знаком с основными концепциями, нормализаций, ACID, транзакциями, и способен писать простые запросы.	
3. Способен проектировать хорошие нормализованные схемы, учитывая при этом типичные запросы, которые будут производится. Профессионально использует отображения (View), хранимые процедуры, триггеры и типы, определяемые пользователем. Понимает отличие кластерных индексов от некластерных. Профессионально использует средства объектно-реляционного отображения.	
4. Способен осуществлять базовое администрирование БД, настройку производительности и оптимизацию индексов. Создавать сложные запросы, заменять использование курсоров на выражения SQL. Представляет, как данные и индексы физически организованы. Понимает, как база может быть зеркалирована, реплицируема. Понимает, как работает двухфазная фиксация (commit).




# Опыт

Профессионально используемые языки
1. Императивные или объектно-ориентированные	
2. Императивные, объектно-ориентированные и декларативные (SQL). Понимает отличия статической и динамической, сильной и слабой типизации. Статический вывод типов.	
3. Функциональные. Ленивые вычисления, каррирование, продолжения (континуации, continuations)	
4. Параллельные (Erlang, Oz) и логические (Prolog)






# Самообразование и развитие

Изучаемые языки/сфера интересов
1. Императивные или объектно-ориентированные	
2. Императивные, объектно-ориентированные и декларативные (SQL). Понимает отличия статической и динамической, сильной и слабой типизации. Статический вывод типов.	
3. Функциональные. Ленивые вычисления, каррирование, продолжения (континуации, continuations)	
4. Параллельные (Erlang, Oz) и логические (Prolog)

Знакомство с технологиями «на гребне волны»
1. Не следит за новыми выпусками платформ, сред разработки и т.п.	
2. Ознакамливается с планами выпусков, представляет, о каких продуктах идёт речь	
3. Загружает предварительные версии продуктов, читает статьи, руководства.	
4. Экспериментирует с предварительными версиями, создаёт пробные решения. Опубликовывает интересные результаты для сообщетва.















======================================Бэкенд======================================
===========================================================================================


# PHP
# SQL
# Работа с технологиями
# Взаимодействия с сервером Unix
# Bitrix
# Front-end
